# -*- coding: utf-8 -*-
"""various_stock_working_fully_final_lstm_cnn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rlQNqf9tWx21gklUkKOImDcK-HUrcm9-
"""

!pip install ta
!pip install alpha_vantage

from alpha_vantage.timeseries import TimeSeries
import threading
import pandas as pd
import pandas_datareader.data as web
import datetime
from sklearn import linear_model
from time import sleep
import joblib
import ta
import pandas as pd
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from keras.models import Sequential
from sklearn import preprocessing
from ta.volatility import BollingerBands
from ta.trend import MACD
from ta.momentum import RSIIndicator
from keras.models import Sequential
from keras.layers import Conv1D,MaxPool1D,Bidirectional,LSTM,Dropout,TimeDistributed
from keras.layers import Dense,GlobalAveragePooling2D
from ta.trend import IchimokuIndicator
from sklearn.linear_model import LinearRegression
from keras.layers import Conv1D,Flatten,MaxPooling1D,Bidirectional,LSTM,Dropout,TimeDistributed,MaxPool2D
from keras.layers import Dense,GlobalAveragePooling2D
import matplotlib.pyplot as plt

stock_name_dict={'Apple':'AAPL','Microsoft':'MSFT','Alphabet':'GOOG','Amazon':'AMZN','Tesla':'TSLA'}

def pred(stock_name):
  global filename
  filename = stock_name_dict[stock_name]
  global stock
  stock=pd.read_csv(f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&symbol={filename}&outputsize=full&apikey=Y8NJBW57JYKKHU3Y&datatype=csv')

pred('Microsoft')
indicator_bb = BollingerBands(stock["close"],20, 2)
macd = MACD(close=stock["close"])
rsi = RSIIndicator(close=stock["close"])
ichi = IchimokuIndicator(high=stock["high"],low=stock["low"])

stock['macd'] = macd.macd()
stock['rsi'] = rsi.rsi()

stock['bb_bbm'] = indicator_bb.bollinger_mavg()
stock['bb_bbh'] = indicator_bb.bollinger_hband()
stock['bb_bbl'] = indicator_bb.bollinger_lband()

stock['ichi_a'] = ichi.ichimoku_a()
stock['ichi_b'] = ichi.ichimoku_b()
stock['ichi_base'] = ichi.ichimoku_base_line()
stock['ichi_conv'] = ichi.ichimoku_conversion_line()

stock = stock.fillna(0)  
print(stock)

scaler = preprocessing.MinMaxScaler()
scaled_values = scaler.fit_transform(stock.iloc[:,1:4])
stock.iloc[:,1:4] = scaled_values

y_scaler = preprocessing.MinMaxScaler()
scaled_values = y_scaler.fit_transform(np.array(stock.iloc[:,4]).reshape(-1,1))
stock.iloc[:,4] = scaled_values

scaler = preprocessing.MinMaxScaler()
scaled_values = scaler.fit_transform(stock.iloc[:,5:])
stock.iloc[:,5:] = scaled_values

Lstock = stock.drop(['close','timestamp',],1)
model = LinearRegression()
print(Lstock)
model.fit(Lstock.iloc[:,:], stock.iloc[:,4])

importance = model.coef_
for i,v in enumerate(importance):
	print('Feature: %0d, Score: %.5f' % (i,v))

stock_final = stock.drop(['timestamp','adjusted_close','volume','macd','bb_bbm','bb_bbh','bb_bbl','ichi_a','ichi_conv','rsi','ichi_b','ichi_base','dividend_amount','split_coefficient'],1)
print(stock)
window_size = 50
week = 7
X = []
Y = []
print(stock_final)
for i in range(0 , len(stock) - window_size -1 , 1):
    # first = stock.iloc[i, 4]
    # temp = []
    # temp2 = []
    # for j in range(window_size):
    #     temp.append((stock_final.iloc[i + j, 4] - first) / first)
   # for j in range(week):

    X.append(np.array(stock_final.iloc[i:i+window_size,:]).reshape(window_size * 4,1))
    Y.append(np.array(stock.iloc[i+window_size,4]).reshape(1,1))
    # print(stock2.iloc[i:i+window_size,4])
    # X.append(np.array(temp).reshape(50, 1))
    # Y.append(np.array(temp2).reshape(1,1))
train_X,test_X,train_label,test_label = train_test_split(X, Y, test_size=0.1,shuffle=False)
len_t = len(train_X)

# train_X,valid_X,train_label,valid_label = train_test_split(train_X, train_label, test_size=0.2,shuffle=True)
train_X = np.array(train_X)
print(train_X.shape)
test_X = np.array(test_X)
print(test_X.shape)
train_label = np.array(train_label)
test_label = np.array(test_label)
# valid_label = np.array(valid_label)
# valid_X = np.array(valid_X)

train_X = train_X.reshape(train_X.shape[0],4,50,1)
print(train_X.shape)
test_X = test_X.reshape(test_X.shape[0],4,50,1)

model = Sequential()
#add model layers
model.add(TimeDistributed(Conv1D(128, kernel_size=1, activation='relu', input_shape=(4,50,1))))
model.add(TimeDistributed(MaxPooling1D(2)))
model.add(TimeDistributed(Conv1D(256, kernel_size=1, activation='relu')))
model.add(TimeDistributed(MaxPooling1D(2)))
model.add(TimeDistributed(Conv1D(512, kernel_size=1, activation='relu')))
model.add(TimeDistributed(MaxPooling1D(2)))
model.add(TimeDistributed(Flatten()))



model.add(Bidirectional(LSTM(200,return_sequences=True)))
model.add(Dropout(0.25))
model.add(Bidirectional(LSTM(200,return_sequences=False)))
model.add(Dropout(0.5))
model.add(Dense(1, activation='linear'))

model.compile(optimizer='adam', loss='mse')
model.fit(train_X, train_label, validation_data=(test_X,test_label), epochs=50)
def getmodel():
  return 
joblib.dump(model, "modelLR.pkl")
print(model.summary())



key = 'Y8NJBW57JYKKHU3Y'
ts = TimeSeries(key, output_format='pandas')
data, meta = ts.get_intraday(filename, interval='60min', outputsize='compact')

df=data.drop(['5. volume'],1)
df=df.fillna(0)
#print(df.columns)
df.columns=stock_final.columns[0:4]
j=0
#print(df)
scaler = preprocessing.MinMaxScaler()
df.iloc[:,0:3]=scaler.fit_transform(np.array(df.iloc[:,0:3]))
y_scaler = preprocessing.MinMaxScaler()
scaled_values = y_scaler.fit_transform(np.array(df.iloc[:,3]).reshape(-1,1))
df.iloc[:,3]= scaled_values
#print(df)
window_size=50
X=[]
Y = []
for i in range(0 , len(data) - window_size -1 , 1):
    

    X.append(np.array(df.iloc[i:i+window_size,0:4]).reshape(window_size * 4,1))
    Y.append(np.array(df.iloc[i+window_size,3]).reshape(1,1))

arr=np.array(X)

arr_Y=np.array(Y)
arr_Y=y_scaler.inverse_transform(arr_Y[:,0].reshape(-1,1))

arr=arr.reshape(arr.shape[0],4,50,1)

predicted=model.predict(arr)


predicted = np.array(predicted[:,0]).reshape(-1,1)
predicted = y_scaler.inverse_transform(predicted)


print(predicted)
print(arr_Y)
plt.plot(arr_Y[:,0], color = 'black', label = ' Stock Price')
plt.plot(predicted[:,0], color = 'green', label = 'Predicted  Stock Price')
plt.title(' Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel(' Stock Price')
plt.legend()
plt.show()